2008 0916 2113
Accumulation Buffer与Scene Antialiasing,参考OpenGL Programming Guide 5th Edition p482

2008 0922 1814
关于GPU Skinning,蒙皮矩阵数组大小取决于目标shader model,每个矩阵使用4个连续的常量寄存器,
对于DirectX profile vs_2_0,vs_3_0,最大常量寄存器数为256,理想情况下允许64个蒙皮矩阵.
对于OpenGL profile arbvp1,最大常量寄存器数为96,理想情况下允许24个蒙皮矩阵.

2008 1225 1610
目前的Ray与Triangle相交检测,使用了标准算法,在解线性方程组Q + t*D = b0*E1 + b1*E2时,用了三次叉积运算,
而参照Real-Time Rendering 3th Edition,p746,在外界提供了三角面法线的情况下,我们可以将三次叉积运算缩减到一次.
今后应修改IntrRay3Triangle3中的相关算法.

2008 1225 1618
目前的Collision系统使用了Bounding Volume tree子系统(简称BVT子系统).而该子系统只能针对一般情况下的网格
(不包含使用GPU进行skinning和morph的网格)生成BVT.

2009 0122 1950
在使用牛顿法估算convex function的解时,注意使用的numerical minimizer算法,在SEDistance.cpp中line192,line316.

2009 0122 1951
Vector3到Triangle3距离,Vector3到Rectangle3距离,Line3到Box3距离的算法细节尚未明晰.待相关数学原理明晰后再解决.

2009 0306 1114
智能指针所指对象不需要显示的通过SmartPointer<type> = 0来企图释放,智能指针对象自身析构时会对所指对象减引用.
除非是在application层的用户应用程序派生类的智能指针成员对象,则需要在application层的OnTerminate函数中显示的进行
SmartPointer<type> = 0,因为application派生类中的智能指针成员对象的生存周期大于系统的Object级内存泄漏检测开始时间.

2009 0306 1119
注意,目前取消了Image的power of two检测，为了支持任意尺寸的backbuffer及其对应的offscreen texture(render target),
同时需要注意的是,offscreen texture(render target)的尺寸不能大于backbuffer的尺寸.
在OpenGL 2.0规范中,取消了power of two的限制,可以创建任意尺寸的texture和offscreen texture.
在DirectX9.0规范中,D3DXCreateTextureFromFile/D3DXCreateTextureFromFileEx总是默认创建power of two的纹理,
D3DXCreateTextureFromFileEx函数可以通过指定D3DX_DEFAULT_NONPOW2来试图创建符合原始图形文件尺寸的任意尺寸纹理,
D3DCAPS9::TextureCaps决定了当前设备的纹理能力.
以下摘自SDK文档:
TextureCaps 
Miscellaneous texture-mapping capabilities. This member can be one or more of the following flags. 
D3DPTEXTURECAPS_ALPHA 
Alpha in texture pixels is supported. 
D3DPTEXTURECAPS_ALPHAPALETTE 
Device can draw alpha from texture palettes. 
D3DPTEXTURECAPS_CUBEMAP 
Supports cube textures. 
D3DPTEXTURECAPS_CUBEMAP_POW2 
Device requires that cube texture maps have dimensions specified as powers of two. 
D3DPTEXTURECAPS_MIPCUBEMAP 
Device supports mipmapped cube textures. 
D3DPTEXTURECAPS_MIPMAP 
Device supports mipmapped textures. 
D3DPTEXTURECAPS_MIPVOLUMEMAP 
Device supports mipmapped volume textures. 
D3DPTEXTURECAPS_NONPOW2CONDITIONAL 
D3DPTEXTURECAPS_POW2 is also set, conditionally supports the use of 2D textures with dimensions that are not powers of two. A device that exposes this capability can use such a texture if all of the following requirements are met.

The texture addressing mode for the texture stage is set to D3DTADDRESS_CLAMP. 
Texture wrapping for the texture stage is disabled (D3DRS_WRAP n set to 0). 
Mipmapping is not in use (use magnification filter only). 
Texture formats must not be D3DFMT_DXT1 through D3DFMT_DXT5. 
If this flag is not set, and D3DPTEXTURECAPS_POW2 is also not set, then unconditional support is provided for 2D textures with dimensions that are not powers of two.

A texture that is not a power of two cannot be set at a stage that will be read based on a shader computation (such as the bem - ps and texm3x3 - ps instructions in pixel shaders versions 1_0 to 1_3). For example, these textures can be used to store bumps that will be fed into texture reads, but not the environment maps that are used in texbem - ps, texbeml - ps, and texm3x3spec - ps. This means that a texture with dimensions that are not powers of two cannot be addressed or sampled using texture coordinates computed within the shader. This type of operation is known as a dependent read and cannot be performed on these types of textures.

D3DPTEXTURECAPS_NOPROJECTEDBUMPENV 
Device does not support a projected bump-environment loopkup operation in programmable and fixed function shaders. 
D3DPTEXTURECAPS_PERSPECTIVE 
Perspective correction texturing is supported. 
D3DPTEXTURECAPS_POW2 
If D3DPTEXTURECAPS_NONPOW2CONDITIONAL is not set, all textures must have widths and heights specified as powers of two. This requirement does not apply to either cube textures or volume textures.

If D3DPTEXTURECAPS_NONPOW2CONDITIONAL is also set, conditionally supports the use of 2D textures with dimensions that are not powers of two. See D3DPTEXTURECAPS_NONPOW2CONDITIONAL description.

If this flag is not set, and D3DPTEXTURECAPS_NONPOW2CONDITIONAL is also not set, then unconditional support is provided for 2D textures with dimensions that are not powers of two.

20090423 1940
目前已知Cg runtime bug:
saturate函数会引起编译后的程序由cgD3D9LoadProgram产生Unknown error. 库版本为Cg toolkit2.2 February2009

20090706 2255
注意含有指针成员的类的拷贝构造和赋值运算符重载问题.
目前RendererConstant,UserConstant,SamplerInformation类都允许携带用户自定义数据指针,应注意实现带有指针成员的类拷贝构造函数.
从而明确定义当拷贝构造发生时,指针成员的具体行为,目前这三个类都应该采用指针成员的内存动态分配策略.从而避免产生因类对象析构等原因
释放自定义数据指针造成的共享指针内存非法.
Program类虽然也含有自定义数据指针,但如果可以确定在使用过程中该类不会发生拷贝构造或对象赋值,则暂时无需实现明确定义的拷贝构造函数.

20090815 2300
关于VC编译器warning C4251
1:情况一
如果类的定义里面仅含有 编译器内置的类型变量, int, float 等等. 或者成员函数仅使用了这些变量作为参数, 那么很简单.
直接
class __declspec(dllexport) YourClass
{
}
就行了.

2:情况二
如果类内部使用了别的类, 那么别的类最好也导出, 不然, 首先编译的时候会出现编译警告:
 warning C4251: needs to have dll-interface 
意思是,你使用另外的一些类型/接口, 但是这些类型或接口没有导出. 当你的client使用这些类型/接口的时候, 会出错!
class __declspec(dllexport) YourClass
{
   YourAnatherClass m_data; // 这里会 出现 warning 4251. 如果YourAnatherClass 没有导出的话.
}
解决办法就是: 在YourAnatherClass定义的地方加上
class __declspec(dllexport) YourAnatherClass 
{
}
如上, 当你的YourAnatherClass没有导出的时候, dll的使用方会出现链接错误

3:情况三
当类的内部使用了STL模板的时候, 也会出现C4251警告, 情况会有所不同
class __declspec(dllexport) YourClass
{
   vector<int> m_data; // 这里会 出现 warning 4251. 因为vector<int>类型没有被导出
}
上面的使用模板(无论是stl模板,还是自定义模板)的代码,编译dll时会出现C4251警告, 但是dll的使用方, 却不会出现链接错误!!!
这个因为, dll的使用方那里也有一套模板的定义, 当他们使用那个vector<int>的时候, 虽没有导出, 但是用户自己也有一套STL模板(或者是自定义的模板),用户会利用自己的模板实例化这个dll中没有导出的东西!

所以, 对于因为使用STL(或模板)出现的c4251警告, 关闭之即可
#pragma warning(push)
#pragma warning(disable:4251)
//your declarations that cause 4251
#pragma warning(pop)

若想不使用通过关闭警告的方式关闭警告, 那么就这样
1)对于用户自定义的模板
   template class DLLImportExportMacro SomeTemplate<int>;
   SomeTemplate<int> y;
2)对于STL的模板
     template class DLLImportExportMacro std::allocator<int>
     template class DLLImportExportMacro std::vector<int,
      std::allocator<int> >;
     vector<int> m_data;

2009 1006 2202
对于返回值为智能指针的函数,如果不能确定被引用对象的当前引用计数是否大于零,则一定要使用智能指针来接收返回值,例如:
ObjectPtr DoSomething(...);
ObjectPtr spObject = DoSomething(...);
这将保证返回值所指向的对象的引用计数大于等于1,从而不会造成内存空间因为引用计数变为零时的意外释放.

2009 1029 1802
在Mac OS X 10.6系统下,使用Versions软件checkout后,获取到的项目shell脚本文件无法被Xcode 3.2运行,Xcode提示permission denied,但从本地直接拷贝覆盖这些shell脚本文件后,
Xcode就可以正确执行了,目前尚未查明原因.

2009 1030 2120
Xcode使用GCC4.x编译器时,项目生成目标的Code Generation项下,Inline Methods Hidden和Symbols Hidden by Default两个子项均应该取消勾选.
参考: http://developer.apple.com/mac/library/documentation/DeveloperTools/Conceptual/CppRuntimeEnv/Articles/SymbolVisibility.html

2009 1111 0834
应用程序中的用户摄像机如果在WindowApplication3::OnTerminate()之前释放,则有可能造成野指针异常(当程序退出时,如果renderer正在引用用户的摄像机对象,而该对象已经在
WindowApplication3::OnTerminate()之前释放,由于renderer引用摄像机使用的是普通指针,则将产生野指针异常).目前为了确保安全,最好把摄像机释放代码写在
WindowApplication3::OnTerminate()之后,或者确保程序退出时,renderer正在引用应用层提供的默认摄像机对象.可参考ScreenSpaceAO例子.

2009 1111 0902
由于OpenGL API的特殊性,在使用Framebuffer对象时,应首先调用Renderer::ClearBuffers()函数,从而确保后续渲染能够成功.可参考ScreenSpaceAO例子.

2010 0113
关于使用多个Renderer对象:
在需要对多个渲染窗口进行渲染输出时,应为每个窗口建立一个Renderer对象(比如开发Windows Form应用程序),目前只有DX9Renderer测试过此项功能,DX9Renderer使用了Cg/CgD3D9运行时库,
由于CgD3D9库的设计缺陷,造成Cg context无法与DX9 device建立一对一维护关系(cgD3D9运行时维护并引用着一个全局D3D9 device对象,运行时只能将所有Cg context所维护的Cg program
和Cg paramter资源装载到该D3D9 device对象,或从该对象释放这些资源. 参考cgD3D9SetDevice函数,该函数只接收并维护当前使用的D3D9 device,而不为Cg context建立映射关系,
 CgD3D10修复了这个缺陷,参考cgD3D10SetDevice函数),因此,为了支持同时使用多个Renderer,DX9Renderer必须在使用自己的Cg shader资源之前,通过调用cgD3D9SetDevice函数,
将自己的D3D9 device绑定给CgD3D9运行时,之后这些Cg shader资源会被首次/再次装载到该D3D9 device(由CgD3D9内部管理).因此在多个Renderer之间切换渲染时,之前Renderer所使用device的
shader program资源会被释放,当前待使用Renderer所使用的device的shader program资源会被重新装载,这会有一定的性能损失,目前没有其他更好的解决办法.

2010 0303 1136
关于使用Controller的骨骼动画节点:
应通过某些动画管理系统(尚未实现),让骨骼动画节点树先于被控几何节点树进行geometry update操作。
考虑这种情况:从一个根节点处进行geometry update操作,假设其下有两个子树节点,则左子树(第一个子节点)首先进行geometry update操作,此时右子树(骨骼动画节点树)尚未更新,左子树的
更新结果如果依赖于右子树,则该结果为右子树上次更新后的结果.
综上所述,采用优先更新骨骼动画树的策略,则上述问题得以解决.

2010 0303 1146
关于使用缩放变换的一些注意事项:
显然我们已经知道:
1 统一缩放变换会改变向量长度,非统一缩放在此基础上还会改变向量的空间姿态.
2 缩放变换会改变空间中两点间的距离.
因此提出一些注意事项:
1 在模型空间进行光照计算有可能会受到限制,当考虑光源与被照射点的距离造成的强度衰减问题时,该距离可能已经被缩放变换变大或缩小.
2 对法线进行空间变换时,如果该变换包含非统一缩放,则应使用变换矩阵的逆的转置,确保法线相对于几何体表面的垂直姿态.
3 单位向量在缩放变换后,有可能需要重新规范化.
4 Picking System,目前通过遍历场景视图,得到一组与当前射线相交的几何体,并保存了每个相交几何体的射线t值,系统返回t值最小的几何体作为最近相交物体.
当某些几何体包含缩放变换,而另外一些几何体不包含,那么包含缩放变换的几何体的t值应调整,否则最小t值比较将失去意义.目前系统尚未实现调整t值的功能.

2010 0318 1304
发现一个bug,当某个Effect所使用的shader program被释放后,稍后重新创建该Effect对象,造成所需shader program重新装载,此时由于很多Effect都是用类静态bool成员
跟踪shader constant一次性初始化问题,造成重新装载的shader porgram无法重新初始化,稍后将解决此问题.

2010 0325 1643
一定要确保类成员的正确初始化(在构造函数中),某些debug和release版程序运行结果不一致的问题,很有可能是由未能初始化的类成员变量造成的.

2010 0526 0950
在dot net应用程序中,新建一个Form时,如果更改了该Form的类名(比如更改了默认命名空间),则应该同时更改该Form的.resx文件中的Resource File Name.
比如:
系统默认创建的Form类:
namespace RootNamespace(这个是系统根据当前项目名称默认使用的命名空间,在C++项目中目前不知道如何更改这个值)
{
public ref class SomeForm : public Form
{
...
};

}
我们把该类更改如下:
namespace MyNamespace(这个是我们所期望的该类所属命名空间)
{
public ref class SomeForm : public Form
{
...
};

}
此时问题就来了,观察SomeForm所属的.resx文件的属性页面,Managed Resources->General->Resource File Name的值,此时依然为系统默认的
$(IntDir)\$(RootNamespace).$(InputName).resources
具体含义是,当编译器编译该Form代码模块后,会根据这个值生成对应的模块资源文件RootNamespace.SomeForm.resources,
而并没有生成我们所期望的MyNamespace.SomeForm.resources,之后在链接阶段,编译器就无法将该资源文件里的内容写入最终的Assembly模块,
从而当程序在运行阶段,寻找该资源文件里的内容时,产生运行时异常.
解决办法是,修改.resx文件的属性页面,Managed Resources->General->Resource File Name的值,从默认的$(IntDir)\$(RootNamespace).$(InputName).resources
改为该类的实际名称,对应我们上面的例子,则应改为$(IntDir)\MyNamespace.$(InputName).resources
如果整个项目都使用同样的Namespace,则可以直接在项目属性页面的Managed Resources->General->Resource File Name项里,统一更改为
$(IntDir)\MyNamespace.$(InputName).resources,然后让所有Form类的.resx文件都继承该项目配置